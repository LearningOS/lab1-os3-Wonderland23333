# 实验一 使我对操作系统的本质有了一定的认识，同时了解了qemu和真实计算机的启动流程，程序的内存布局和编译过程。
* 将PC寄存器设置为ROM物理地址,运行ROM固件初始化，将bootloader的代码和数据从硬盘载入物理内存中，跳转到bootloader
* 由bootloader加载至物理起始地址0x80000000，进行CPU初始化，并负责将操作系统从硬盘载入物理内存
* 跳转至操作系统，操作系统开始一系列工作
* 已初始化数据段存放已初始化的全局数据，有只读全局数据放在.rodata和可修改全局数据存放于.data
* 为初始化数据段放在.bss中，由程序加载着戴维进行零初始化，类似C++中定义未赋值的全局变量
* 堆（heap）存放程序运行时动态分配的数据，向高地址增长
* 栈（stack）不仅用作函数调用上下文的保存与恢复，每个函数作用域的局部变量也存放在栈桢内，向低地址增长
* 编译流程是编译器将源文件转换成汇编文件，再有汇编器将当前源文件转换成机器码，最后通过链接器将目标文件与一些可能的外部文件链接得到可执行文件
* 链接器会将不同目标文件的段在目标内存中重新排布，同时将相同功能的段放在新的同一个大部分，以此消除冲突

# 实验二 使我理解了特权级机制的主要目的，如何实现和具体特性，以及批处理系统的内容

* 保护操作系统不受有意或无意出错的程序破坏的机制被称为 特权级 (Privilege) 机制，它实现了用户态和内核态的隔离，需要软件和硬件的共同努力。
    * 设置特全集的主要目的是由于应用程序运行的安全性不可充分信任，从而对软件设置了一定的条件
    * 一方面要对应用程序作出一定的限制，另一方面能得到操作系统的服务。即应用程序和操作系统还需要有交互的手段。使得低特权级软件都只能做高特权级软件允许它做的，且低特权级软件的超出其能力的要求必须寻求高特权级软件的帮助。
    * 处理器在执行一条指令前回进行特权级安全检查
    * ecall ：具有用户态到内核态的执行环境切换能力的函数调用指令
    * eret ：具有内核态到用户态的执行环境切换能力的函数返回指令（RISC-V中有类似的 sret 指令）
    * 每个特权级都对应一些特殊指令和 控制状态寄存器 (CSR, Control and Status Register) ，来控制该特权级的某些行为并描述其状态
    * RISC-V特权级中，只有M特权级是必须实现的
    * 在 Trap 前的特权级不会高于Trap后的特权级


# 实验三 让我明白了多道程序和分时处理系统的核心和具体实现

* 能够一次性加载所有用户程序，减少任务切换的开销
* 支持任务切换机制，保存切换前后程序上下文
* 支持程序主动放弃处理器，实现yield系统调用
* 以时间片转轮算法调度用户程序，实现资源的时分复用
* 抢占式操作系统是任务随时都有可能被切换出去
* 应用程序的一次执行过程称为一个任务
* 任务切换时来自两个不同应用在内核中的Trap控制流之间的切换
* _switch函数的核心是能够进行换栈，变换sp地址到任务上下文
* 内核栈用于保存应用执行状态的Trap上下文，内核在对Trap处理时留下的调用栈信息，以及一些寄存器信息。
* 在内存中尽量同时驻留多个应用，但只有一个程序执行完毕后或主动放弃执行，处理器才能执行另外一个程序。这种运行方式称为多道程序
* 多个应用程序被一次性地加载到内存中，这样在切换到另外一个应用程序执行会很快，不需清空前一个应用，然后加载当前应用的过程与开销。
* 任务切换不涉及特权级切换，它的一部分工作是由编译器帮忙完成的，它对应用是透明的。事实上，它是来自两个不同应用的 Trap 执行流之间的切换。当一个应用 Trap 到 S 模式的操作系统中进行进一步处理的时候，其 Trap 执行流可以调用一个特殊的 switch 函数。这个函数表面上就是一个普通的函数调用：在 switch 返回之后，将继续从调用该函数的位置继续向下执行。但是其间却隐藏着复杂的执行流切换过程。具体来说，调用 switch 之后直到它返回前的这段时间，原 Trap 执行流会先被暂停并被切换出去， CPU 转而运行另一个应用的 Trap 执行流。之后在时机合适的时候，原 Trap 执行流才会从某一条 Trap 执行流（很有可能不是它之前切换到的那一条）切换回来继续执行并最终返回。不过，从实现的角度讲， switch 和一个普通的函数之间的差别仅仅是它会换栈
* 对于某个处理器核而言， 陷入与发起 陷入 的指令执行是 同步 (Synchronous) 的，陷入被触发的原因一定能够追溯到某条指令的执行；而中断则 异步 (Asynchronous) 于当前正在进行的指令，也就是说中断来自于哪个外设以及中断如何触发完全与处理器正在执行的当前指令无关。
