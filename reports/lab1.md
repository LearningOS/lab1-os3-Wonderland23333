# 实验一 使我对操作系统的本质有了一定的认识，同时了解了qemu和真实计算机的启动流程，程序的内存布局和编译过程。
* 将PC寄存器设置为ROM物理地址,运行ROM固件初始化，将bootloader的代码和数据从硬盘载入物理内存中，跳转到bootloader
* 由bootloader加载至物理起始地址0x80000000，进行CPU初始化，并负责将操作系统从硬盘载入物理内存
* 跳转至操作系统，操作系统开始一系列工作
* 已初始化数据段存放已初始化的全局数据，有只读全局数据放在.rodata和可修改全局数据存放于.data
* 为初始化数据段放在.bss中，由程序加载着戴维进行零初始化，类似C++中定义未赋值的全局变量
* 堆（heap）存放程序运行时动态分配的数据，向高地址增长
* 栈（stack）不仅用作函数调用上下文的保存与恢复，每个函数作用域的局部变量也存放在栈桢内，向低地址增长
* 编译流程是编译器将源文件转换成汇编文件，再有汇编器将当前源文件转换成机器码，最后通过链接器将目标文件与一些可能的外部文件链接得到可执行文件
* 链接器会将不同目标文件的段在目标内存中重新排布，同时将相同功能的段放在新的同一个大部分，以此消除冲突

# 实验二 使我理解了特权级机制的主要目的，如何实现和具体特性，以及批处理系统的内容

* 保护操作系统不受有意或无意出错的程序破坏的机制被称为 特权级 (Privilege) 机制，它实现了用户态和内核态的隔离，需要软件和硬件的共同努力。
    * 设置特全集的主要目的是由于应用程序运行的安全性不可充分信任，从而对软件设置了一定的条件
    * 一方面要对应用程序作出一定的限制，另一方面能得到操作系统的服务。即应用程序和操作系统还需要有交互的手段。使得低特权级软件都只能做高特权级软件允许它做的，且低特权级软件的超出其能力的要求必须寻求高特权级软件的帮助。
    * 处理器在执行一条指令前回进行特权级安全检查
    * ecall ：具有用户态到内核态的执行环境切换能力的函数调用指令
    * eret ：具有内核态到用户态的执行环境切换能力的函数返回指令（RISC-V中有类似的 sret 指令）
    * 每个特权级都对应一些特殊指令和 控制状态寄存器 (CSR, Control and Status Register) ，来控制该特权级的某些行为并描述其状态
    * RISC-V特权级中，只有M特权级是必须实现的
    * 在 Trap 前的特权级不会高于Trap后的特权级
